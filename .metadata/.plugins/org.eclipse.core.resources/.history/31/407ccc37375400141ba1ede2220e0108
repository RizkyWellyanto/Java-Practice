// Shlomo Nazarian CS1C Assignment 3 Timing Matrix Multiplication 10-15-14 BS"D

import java.text.*;
import java.util.*;

// Part A-----------------------------------------------------------------------
// Class Foothill---------------------------------------------------------------
public class Foothill
{
   static long startTime;
   static long stopTime;
   
   // -------  proof of correctness --------------
   public static void main(String[] args) throws Exception
   {
      int r, randRow, randCol, matSize = 0, start, size;

      double smallPercent;
      NumberFormat tidy = NumberFormat.getInstance(Locale.US);
      tidy.setMaximumFractionDigits(5);
      Scanner inputStream = new Scanner(System.in);
      
      // non-sparse matrices
      double[][] mat, matAns;
      
      // testing if mat mult gives good values without caring about time
      System.out.println("testing matrix multiplication");
      
      matSize = 3;
      mat = new double[matSize][matSize];
      matAns = new double[matSize][matSize];
      
      for (int row = 0; row < mat.length; row++)
         for (int col = 0; col < mat[row].length; col++)
            mat[row][col] = 15 + (1 + col) + (row*3); 
      
      // show submatrix before square
      System.out.println("Before Multiplying");
      matShow(mat, 0, 3);
      
      matMult(mat, mat, matAns);
      
      // show submatrix after square
      System.out.println("After Multiplying");
      matShow(matAns, 0, 3);
      
      // 10 runs to compare times
      for (int runs = 1; runs <= 10; runs++)
      {
         matSize = 0;
         // get matSize from user
         while (matSize < 1)
         {
            System.out.print("Run " + runs + "-------------------------------\n"
               + "Enter size of Matrix no less than 1: ");
            matSize = inputStream.nextInt();
         }
         
         // allocate matrices
         mat = new double[matSize][matSize];
         matAns = new double[matSize][matSize];
         
          
         // generate small% of non-default values bet 0 and 1
         smallPercent = matSize/10. * matSize;
         for (r = 0; r < smallPercent; r++)
         {
            randRow = (int)(matSize * Math.random());
            randCol = (int)(matSize * Math.random());
            
            mat[randRow][randCol] = Math.random();
         }
         
         // get random dimensions for matShow()
         if (matSize >= 10)
            size = 10;
         else
            size = (int)(matSize * Math.random());
         start = (int)((matSize-size) * Math.random());
         
         
         // show submatrix
         matShow(mat, start, size);
         

         matMult(mat, mat, matAns);

         
         // show submatrix answer
         matShow(matAns, start, size);
         
         System.out.println("\nSize = " + matSize + " Mat. Mult. Elapsed Time: "
            + tidy.format( (stopTime - startTime) / 1e9) + " seconds.\n\n");
      }
   }
   
   public static void matMult( double[][] matA,  double[][] matB, 
      double[][] matC)
   {
      // dimensions check
      for (int row = 0; row < matA.length; row++)
         if (matA[row].length != matB[row].length)
            return;
      
      startTime = System.nanoTime();
      
      
      // matrix multiplication by dot product of rows of matA & cols of matB
      for (int row = 0; row < matC.length; row++)
         for (int col = 0; col < matC[row].length; col++)
            for (int c = 0; c < matC[row].length; c++)
               matC[row][col] += matA[row][c] * matB[c][col];
      
      stopTime = System.nanoTime();
   }
   
   public static void matShow(double[][] matA, int start, int size)
   {
      if (start < 0 || size < 0 || start + size > matA.length 
         || start + size > matA[0].length)
         return;
      
      for (int row = start; row < start + size; row++)
      {
         for (int col = start; col < start + size; col++)
            System.out.print( String.format("%4.4f", matA[row][col]) + " " );
         System.out.println();
      }
      System.out.println();
   }
}
// End Class Foothill-----------------------------------------------------------

/*-Run--------------------------------------------------------------------------
----HAVENT DONE A RUN YET
------------------------------------------------------------------------------*/

/*-Questions to answer----------------------------------------------------------
1 What was the smallest M that gave you a non-zero time?
2 What happened when you doubled M, tripled it, quadrupled it, etc?  Give 
several M values and their times in a table.
3 How large an M can you use before the program refuses to run (exception or 
run-time error due to memory overload) or it takes so long you can't wait for 
the run?
Run 1-------------------------------
Enter size of Matrix no less than 1: 11000
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at 
Foothill.main(Foothill.java:58)
4 How did the data agree or disagree with your original time complexity estimate?
------------------------------------------------------------------------------*/